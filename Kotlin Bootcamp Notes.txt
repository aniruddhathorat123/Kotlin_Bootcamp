Kotlin bootcamp

Advantages of kotlin:
1: ensure about null pointer exception.
2: Avoid much more boiler plate code and take care by itself e.g. getter-setter done by complier.
3: less code and more readeability because of lambda functions.


* Basis:
1: numbers are primitives in kotlin.
2: all the numerical types in kotlin have a supertype called number.
3: Number type won't implicitly convert to other type, need type casting explicitly.

4:	? = indicate variable can be null.
	!! = indicate, you don't know that variable may or may not be null. throws expcetion when it will null.
	user elivs operator(?:) if you are not sure whether variable returns null or not.

5: un-type arrays : arrayOf("item1", 12) and can use toString on it.

6: Every function in kotlin return something, even when there is no explicitly return specified. So like Main function return type is "Unit" which is kotlin way of saying no value.

7: TO convert inline : Alt+Shift+Enter

8: function with default argument may be expensive to use.
e.g.: fun acquaStatusReport(acquarium: Any = makeAcquarium())
every time if we didn't pass the argument it creates the new acquarium.

9: most of the things in kotlin are like the expression but there is while and for loop are exceptions for this.
find about more grammer : koltinlang.org

10: kotlin filters: 
compare and return the value which true for the given condition.
'' = should contain single designated charachter
"" = consider as string.

filter are kind of eager learner.
asSequence is kind of lazy learner.

lambdas are the expression which makes the function.
{ println("Hello") }()

*****
val half = { num: Int -> num/2} OR val half : (Int) -> Int = { num -> num/2}

half(20)
res10: kotlin.Int = 10
*****

Lambdas are more useful with higher order function which takes the function as argument.

Kotlin prefers function parameter to be the last one.

********************
1. val random1 = random()
2: val random2 = { random() }

random1 has a value assigned at compile time, and the value never changes when the variable is accessed.

random2 has a lambda assigned at compile time, and the lambda is executed every time the variable is referenced, returning a different value.
********************

# Classes and Constructors:

Access Specifiers: 
1. public by default same as java.
2. private in same file only.
3. Internal : Visible anywhere in the same module.
 	Module : Set of kotline files compiled together.
4. Protected: inside class and sub-class can see it.

 - variable without var or val in constructor parameter, kotlin does not create property for that variable. (Property for variable will be getter or setter)

 - init {} works just like constructor, you can have more than one init block and they always run before any secondary constructor.

 - Classes in kotlin are inherited from top level class called "Any".

 - To inherit any class you need to open it and for also class members and expressions are not implicitly open, you need to explicitly open them, to avoid accidentally leak of implementation details.

 - Data class provides : - getter and setters
 						 - Equals method to compare two instances of obejct class.

 - Decomposition process: put property value into each variable and then use it.
 	- Number of varible must match to the number of properties, otherwise you get compile time error.
 	- Variable should be assign in order they declared in the class constructor.

 - Singleton class: use "object" instead of class to create your class.
  e.g. : object <class_name>(params...) { }

 - Sealed class: a class that can be subclassed, but only in file which is it declared. because to get info about classes at compile time.
    - sealed classes are the safe way to represent a fixed number of types.


 Pairs: - nest datatype that allows to define generic pair of values.
 	- can used to return more than one value form the function.
 	val data = ("abc" to "xyz") to ("pqr" to "sss")

	println("${data.first.first} to ${data.second.second}")
	abc to sss

	val (firstStudent, secondStudent) = data

	println("Students are: $firstStudent")
	Students are: (abc, xyz)

- list.reverse returns the new list
- list.sublist: create sublist : sublist(<arg1>, <arg2>) create sublist from arg1 excluding the index of arg2.

	listOf("a","b","ert").sumBy { it.length }
	getOrDefault(<required_param>, <default_param>)
	getOrElse(<required_param>) { <else_param> }

- const val is set at compile time.
- consta val is only works with top level and class delcared with object.
- Kotlin does not have class level constants. you have to wrap them in comapnion object.

- Companion object are initialize from the static constructor of the containing class. plain obect are lazy initialized.

-extenstion functions allows to add function to the existing class without having access to the source code.
- inside extension function , "this" is bound to the instencd on which it is called on.
- extension function does not have access to the private variables.
- extension function are resolved statically.

- can define extionsion properties Class.property.extension  


////

generic classes. <T>
 - for generic you can use any letter or longer name.
 - type can be inferred by the type of argument while creating object.
 - generic(<T>) accepts the null.
 avoid null by <T: Any> : here Any limits the type bound for generic class. you can use any type bound for 

 - In type can only be pass into an object (as parameter).
 - Out type can only be pass out of object or returned (return value).
 - constructor can take out type as parameter but not function.

 - reified: makes (something abstract) more concrete or real
 - use <*> if we dont care what type of generic is used with function call.

 - ALL GENERIC TYPES ARE ONLY USED AT COMPILR TIME BY KOTLIN. RUNTIME ALL GENERICS ARE ERASED TO CREATE COMPLETE CORRECT CODE.

- joinToString : function that returns the string containing the letter with supplied separator.

/////////

Higher order function:

 - with

 fun example(name: String, block: String.() -> Unit )

  - block is the name of function, we can call anything we want.
  - after colon specify the class that we are extending,
  - specify the return type after {->} which is Unit in this case.

- run{} extension function that returns the result of the block function.
- apply{} returns the object it's applied to.
- let{} returns the copy of the changed object. useful for chaining manipulation together.


- for lambda function, it called everytime when it called, creates the memory and cpu overhead, so declaring lambda as inline will replace the function call with actual function instruction at compile time.
}
 
